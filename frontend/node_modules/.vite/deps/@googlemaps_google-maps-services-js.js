import {
  require_axios,
  require_defaults,
  require_settle,
  require_transformData
} from "./chunk-7BZ7AEC4.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-TFWDKVI3.js";

// ../../node_modules/retry-axios/dist/index.module.js
var index_module_exports = {};
__export(index_module_exports, {
  attach: () => r,
  detach: () => t,
  getConfig: () => i,
  shouldRetryRequest: () => f
});
function r(r2) {
  return (r2 = r2 || import_axios.default).interceptors.response.use(n, s);
}
function t(r2, t2) {
  (t2 = t2 || import_axios.default).interceptors.response.eject(r2);
}
function n(e2) {
  return e2;
}
function o(e2) {
  var r2 = [];
  if (e2)
    return Array.isArray(e2) ? e2 : ("object" == typeof e2 && Object.keys(e2).forEach(function(t2) {
      "number" == typeof t2 && (r2[t2] = e2[t2]);
    }), r2);
}
function s(r2) {
  if (import_axios.default.isCancel(r2))
    return Promise.reject(r2);
  var t2 = i(r2) || {};
  if (t2.currentRetryAttempt = t2.currentRetryAttempt || 0, t2.retry = "number" == typeof t2.retry ? t2.retry : 3, t2.retryDelay = "number" == typeof t2.retryDelay ? t2.retryDelay : 100, t2.instance = t2.instance || import_axios.default, t2.backoffType = t2.backoffType || "exponential", t2.httpMethodsToRetry = o(t2.httpMethodsToRetry) || ["GET", "HEAD", "PUT", "OPTIONS", "DELETE"], t2.noResponseRetries = "number" == typeof t2.noResponseRetries ? t2.noResponseRetries : 2, t2.checkRetryAfter = "boolean" != typeof t2.checkRetryAfter || t2.checkRetryAfter, t2.maxRetryAfter = "number" == typeof t2.maxRetryAfter ? t2.maxRetryAfter : 3e5, t2.statusCodesToRetry = o(t2.statusCodesToRetry) || [[100, 199], [429, 429], [500, 599]], r2.config = r2.config || {}, r2.config.raxConfig = Object.assign({}, t2), !(t2.shouldRetry || f)(r2))
    return Promise.reject(r2);
  var n2 = new Promise(function(e2, n3) {
    var o2 = 0;
    if (t2.checkRetryAfter && r2.response && r2.response.headers["retry-after"]) {
      var s3 = function(e3) {
        var r3 = Number(e3);
        if (!Number.isNaN(r3))
          return 1e3 * r3;
        var t3 = Date.parse(e3);
        return Number.isNaN(t3) ? void 0 : t3 - Date.now();
      }(r2.response.headers["retry-after"]);
      if (!(s3 && s3 > 0 && s3 <= t2.maxRetryAfter))
        return n3(r2);
      o2 = s3;
    }
    r2.config.raxConfig.currentRetryAttempt += 1;
    var f2 = r2.config.raxConfig.currentRetryAttempt;
    0 === o2 && (o2 = "linear" === t2.backoffType ? 1e3 * f2 : "static" === t2.backoffType ? t2.retryDelay : (Math.pow(2, f2) - 1) / 2 * 1e3, "number" == typeof t2.maxRetryDelay && (o2 = Math.min(o2, t2.maxRetryDelay))), setTimeout(e2, o2);
  }), s2 = t2.onRetryAttempt ? Promise.resolve(t2.onRetryAttempt(r2)) : Promise.resolve();
  return Promise.resolve().then(function() {
    return n2;
  }).then(function() {
    return s2;
  }).then(function() {
    return t2.instance.request(r2.config);
  });
}
function f(e2) {
  var r2 = e2.config.raxConfig;
  if (!r2 || 0 === r2.retry)
    return false;
  if (!e2.response && (r2.currentRetryAttempt || 0) >= r2.noResponseRetries)
    return false;
  if (!e2.config.method || r2.httpMethodsToRetry.indexOf(e2.config.method.toUpperCase()) < 0)
    return false;
  if (e2.response && e2.response.status) {
    for (var t2 = false, n2 = 0, o2 = r2.statusCodesToRetry; n2 < o2.length; n2 += 1) {
      var s2 = o2[n2], f2 = e2.response.status;
      if (f2 >= s2[0] && f2 <= s2[1]) {
        t2 = true;
        break;
      }
    }
    if (!t2)
      return false;
  }
  return r2.currentRetryAttempt = r2.currentRetryAttempt || 0, !(r2.currentRetryAttempt >= r2.retry);
}
function i(e2) {
  if (e2 && e2.config)
    return e2.config.raxConfig;
}
var import_axios;
var init_index_module = __esm({
  "../../node_modules/retry-axios/dist/index.module.js"() {
    import_axios = __toESM(require_axios());
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/util.js
var require_util = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePath = exports.encodePath = void 0;
    function encodePath(path) {
      var result = [];
      var start = [0, 0];
      var end;
      var encodePart = function(part) {
        part = part < 0 ? ~(part << 1) : part << 1;
        while (part >= 32) {
          result.push(String.fromCharCode((32 | part & 31) + 63));
          part >>= 5;
        }
        result.push(String.fromCharCode(part + 63));
      };
      for (let i2 = 0, I = path.length || 0; i2 < I; ++i2) {
        end = [Math.round(path[i2].lat * 1e5), Math.round(path[i2].lng * 1e5)];
        encodePart(end[0] - start[0]);
        encodePart(end[1] - start[1]);
        start = end;
      }
      return result.join("");
    }
    exports.encodePath = encodePath;
    function decodePath(encodedPath) {
      let len = encodedPath.length || 0;
      let path = new Array(Math.floor(encodedPath.length / 2));
      let index = 0;
      let lat = 0;
      let lng = 0;
      let pointIndex;
      for (pointIndex = 0; index < len; ++pointIndex) {
        let result = 1;
        let shift = 0;
        let b;
        do {
          b = encodedPath.charCodeAt(index++) - 63 - 1;
          result += b << shift;
          shift += 5;
        } while (b >= 31);
        lat += result & 1 ? ~(result >> 1) : result >> 1;
        result = 1;
        shift = 0;
        do {
          b = encodedPath.charCodeAt(index++) - 63 - 1;
          result += b << shift;
          shift += 5;
        } while (b >= 31);
        lng += result & 1 ? ~(result >> 1) : result >> 1;
        path[pointIndex] = { lat: lat * 1e-5, lng: lng * 1e-5 };
      }
      path.length = pointIndex;
      return path;
    }
    exports.decodePath = decodePath;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../node_modules/crypto-js/core.js
var require_core = __commonJS({
  "../../node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// ../../node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "../../node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base642 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// ../../node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e2 = H[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                W[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a << 5 | a >>> 27) + e2 + W[i2];
              if (i2 < 20) {
                t2 += (b & c | ~b & d) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b ^ c ^ d) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b & c | b & d | c & d) - 1894007588;
              } else {
                t2 += (b ^ c ^ d) - 899497514;
              }
              e2 = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t2;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// ../../node_modules/crypto-js/hmac.js
var require_hmac = __commonJS({
  "../../node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// ../../node_modules/crypto-js/hmac-sha1.js
var require_hmac_sha1 = __commonJS({
  "../../node_modules/crypto-js/hmac-sha1.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.HmacSHA1;
    });
  }
});

// ../../node_modules/@googlemaps/url-signature/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  createSignature: () => createSignature,
  createSignatureForPathAndQuery: () => createSignatureForPathAndQuery,
  signUrl: () => signUrl
});
function createSignatureForPathAndQuery(pathAndQuery, secret) {
  var decodedSecret = decodeSecret(secret);
  var unsafeSignature = (0, import_hmac_sha1.default)(pathAndQuery, decodedSecret).toString(import_enc_base64.default);
  return unsafeSignature.replace(/\+/g, "-").replace(/\//g, "_");
}
function createSignature(unsignedUrl, secret) {
  if (typeof unsignedUrl === "string") {
    unsignedUrl = new URL(unsignedUrl);
  }
  var pathAndQuery = "".concat(unsignedUrl.pathname).concat(unsignedUrl.search);
  return createSignatureForPathAndQuery(pathAndQuery, secret);
}
function signUrl(unsignedUrl, secret) {
  if (typeof unsignedUrl === "string") {
    unsignedUrl = new URL(unsignedUrl);
  }
  return new URL(unsignedUrl.toString() + "&signature=" + createSignature(unsignedUrl, secret));
}
function decodeSecret(secret) {
  var unsafeSecret = secret.replace(/-/g, "+").replace(/_/g, "/");
  return import_enc_base64.default.parse(unsafeSecret);
}
var import_enc_base64, import_hmac_sha1;
var init_index_esm = __esm({
  "../../node_modules/@googlemaps/url-signature/dist/index.esm.js"() {
    import_enc_base64 = __toESM(require_enc_base64());
    import_hmac_sha1 = __toESM(require_hmac_sha1());
  }
});

// ../../node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "../../node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// ../../node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "../../node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i2 = 1; i2 < tokens.length; i2++) {
          input = decodeComponents(tokens, i2).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i2 = 0; i2 < entries.length; i2++) {
        var key = entries[i2];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// ../../node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "../../node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// ../../node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "../../node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// ../../node_modules/query-string/index.js
var require_query_string = __commonJS({
  "../../node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/serialize.js
var require_serialize = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/serialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPremiumPlanQueryString = exports.toTimestamp = exports.serializer = exports.latLngArrayToStringMaybeEncoded = exports.toLatLngLiteral = exports.latLngBoundsToString = exports.objectToString = exports.latLngToString = void 0;
    var util_1 = require_util();
    var url_signature_1 = (init_index_esm(), __toCommonJS(index_esm_exports));
    var query_string_1 = require_query_string();
    var separator = "|";
    function latLngToString(o2) {
      if (typeof o2 === "string") {
        return o2;
      } else if (Array.isArray(o2) && o2.length === 2) {
      } else if ("lat" in o2 && "lng" in o2) {
        o2 = [o2.lat, o2.lng];
      } else if ("latitude" in o2 && "longitude" in o2) {
        o2 = [o2.latitude, o2.longitude];
      } else {
        throw new TypeError();
      }
      return o2.map((x) => {
        return x.toString();
      }).join(",");
    }
    exports.latLngToString = latLngToString;
    function objectToString(o2) {
      if (typeof o2 === "string") {
        return o2;
      } else {
        let keys = Object.keys(o2);
        keys.sort();
        return keys.map((k) => k + ":" + o2[k]).join(separator);
      }
    }
    exports.objectToString = objectToString;
    function latLngBoundsToString(latLngBounds) {
      if (typeof latLngBounds === "string") {
        return latLngBounds;
      } else {
        return latLngToString(latLngBounds.southwest) + separator + latLngToString(latLngBounds.northeast);
      }
    }
    exports.latLngBoundsToString = latLngBoundsToString;
    function toLatLngLiteral(o2) {
      if (typeof o2 === "string") {
        const parts = o2.split(",").map(Number);
        return { lat: parts[0], lng: parts[1] };
      } else if (Array.isArray(o2) && o2.length === 2) {
        const parts = o2.map(Number);
        return { lat: parts[0], lng: parts[1] };
      } else if ("lat" in o2 && "lng" in o2) {
        return o2;
      } else if ("latitude" in o2 && "longitude" in o2) {
        return { lat: o2.latitude, lng: o2.longitude };
      } else {
        throw new TypeError();
      }
    }
    exports.toLatLngLiteral = toLatLngLiteral;
    function latLngArrayToStringMaybeEncoded(o2) {
      if (typeof o2 === "string") {
        return o2;
      }
      const concatenated = o2.map(latLngToString).join(separator);
      const encoded = `enc:${(0, util_1.encodePath)(o2.map(toLatLngLiteral))}`;
      if (encoded.length < concatenated.length) {
        return encoded;
      }
      return concatenated;
    }
    exports.latLngArrayToStringMaybeEncoded = latLngArrayToStringMaybeEncoded;
    function serializer(format, baseUrl, queryStringOptions = {
      arrayFormat: "separator",
      arrayFormatSeparator: separator
    }) {
      return (params) => {
        const serializedParams = Object.assign({}, params);
        Object.keys(format).forEach((key) => {
          if (key in serializedParams) {
            serializedParams[key] = format[key](serializedParams[key]);
          }
        });
        if ("client_id" in serializedParams && "client_secret" in serializedParams) {
          return createPremiumPlanQueryString(serializedParams, queryStringOptions, baseUrl);
        }
        return (0, query_string_1.stringify)(serializedParams, queryStringOptions);
      };
    }
    exports.serializer = serializer;
    function toTimestamp(o2) {
      if (o2 === "now") {
        return o2;
      }
      if (o2 instanceof Date) {
        return Math.round(Number(o2) / 1e3);
      }
      return o2;
    }
    exports.toTimestamp = toTimestamp;
    function createPremiumPlanQueryString(serializedParams, queryStringOptions, baseUrl) {
      serializedParams.client = serializedParams.client_id;
      const clientSecret = serializedParams.client_secret;
      delete serializedParams.client_id;
      delete serializedParams.client_secret;
      const partialQueryString = (0, query_string_1.stringify)(serializedParams, queryStringOptions);
      const unsignedUrl = `${baseUrl}?${partialQueryString}`;
      const signature = (0, url_signature_1.createSignature)(unsignedUrl, clientSecret);
      return `${partialQueryString}&signature=${signature}`;
    }
    exports.createPremiumPlanQueryString = createPremiumPlanQueryString;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/directions.js
var require_directions = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/directions.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.directions = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var serialize_1 = require_serialize();
    var client_1 = require_client();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/directions/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      origin: serialize_1.latLngToString,
      destination: serialize_1.latLngToString,
      waypoints: (o2) => o2.map(serialize_1.latLngToString),
      arrival_time: serialize_1.toTimestamp,
      departure_time: serialize_1.toTimestamp
    }, exports.defaultUrl);
    function directions(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      const { optimize } = params;
      if (optimize) {
        params.waypoints = ["optimize:true", ...params.waypoints];
      }
      delete params.optimize;
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.directions = directions;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/distance.js
var require_distance = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/distance.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distancematrix = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var serialize_1 = require_serialize();
    var client_1 = require_client();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/distancematrix/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      origins: (o2) => o2.map(serialize_1.latLngToString),
      destinations: (o2) => o2.map(serialize_1.latLngToString),
      arrival_time: serialize_1.toTimestamp,
      departure_time: serialize_1.toTimestamp
    }, exports.defaultUrl);
    function distancematrix(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.distancematrix = distancematrix;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/elevation.js
var require_elevation = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/elevation.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elevation = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/elevation/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      locations: (o2) => o2.map(serialize_1.latLngToString),
      path: (o2) => o2.map(serialize_1.latLngToString)
    }, exports.defaultUrl);
    function elevation(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.elevation = elevation;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/findplacefromtext.js
var require_findplacefromtext = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/findplacefromtext.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findPlaceFromText = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/findplacefromtext/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({}, exports.defaultUrl, { arrayFormat: "comma" });
    function findPlaceFromText(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.findPlaceFromText = findPlaceFromText;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/geocode/geocode.js
var require_geocode = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/geocode/geocode.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.geocode = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/geocode/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      bounds: serialize_1.latLngBoundsToString,
      components: serialize_1.objectToString
    }, exports.defaultUrl);
    function geocode(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.geocode = geocode;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/roads/nearestroads.js
var require_nearestroads = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/roads/nearestroads.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nearestRoads = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://roads.googleapis.com/v1/nearestRoads";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      points: (o2) => o2.map((latLng) => (0, serialize_1.latLngToString)(latLng))
    }, exports.defaultUrl);
    function nearestRoads(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.nearestRoads = nearestRoads;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/autocomplete.js
var require_autocomplete = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/autocomplete.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.placeAutocomplete = exports.defaultParamsSerializer = exports.defaultUrl = exports.PlaceAutocompleteType = void 0;
    var serialize_1 = require_serialize();
    var client_1 = require_client();
    var PlaceAutocompleteType;
    (function(PlaceAutocompleteType2) {
      PlaceAutocompleteType2["geocode"] = "geocode";
      PlaceAutocompleteType2["address"] = "address";
      PlaceAutocompleteType2["establishment"] = "establishment";
      PlaceAutocompleteType2["regions"] = "(regions)";
      PlaceAutocompleteType2["cities"] = "(cities)";
    })(PlaceAutocompleteType = exports.PlaceAutocompleteType || (exports.PlaceAutocompleteType = {}));
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/autocomplete/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      location: serialize_1.latLngToString,
      origin: serialize_1.latLngToString
    }, exports.defaultUrl);
    function placeAutocomplete(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.placeAutocomplete = placeAutocomplete;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/details.js
var require_details = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/details.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.placeDetails = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/details/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({}, exports.defaultUrl, { arrayFormat: "comma" });
    function placeDetails(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.placeDetails = placeDetails;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/photo.js
var require_photo = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/photo.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.placePhoto = exports.defaultUrl = void 0;
    var client_1 = require_client();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/photo";
    function placePhoto(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, responseType } = _a, config = __rest(_a, ["params", "method", "url", "responseType"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      if (!responseType) {
        responseType = "arraybuffer";
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        responseType
      }, config));
    }
    exports.placePhoto = placePhoto;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/queryautocomplete.js
var require_queryautocomplete = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/queryautocomplete.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.placeQueryAutocomplete = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/queryautocomplete/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({ location: serialize_1.latLngToString }, exports.defaultUrl);
    function placeQueryAutocomplete(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.placeQueryAutocomplete = placeQueryAutocomplete;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/placesnearby.js
var require_placesnearby = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/placesnearby.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.placesNearby = exports.defaultParamsSerializer = exports.defaultUrl = exports.PlacesNearbyRanking = void 0;
    var serialize_1 = require_serialize();
    var client_1 = require_client();
    var PlacesNearbyRanking;
    (function(PlacesNearbyRanking2) {
      PlacesNearbyRanking2["prominence"] = "prominence";
      PlacesNearbyRanking2["distance"] = "distance";
    })(PlacesNearbyRanking = exports.PlacesNearbyRanking || (exports.PlacesNearbyRanking = {}));
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/nearbysearch/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({ location: serialize_1.latLngToString }, exports.defaultUrl);
    function placesNearby(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.placesNearby = placesNearby;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/geocode/reversegeocode.js
var require_reversegeocode = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/geocode/reversegeocode.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reverseGeocode = exports.defaultParamsSerializer = exports.defaultUrl = exports.ReverseGeocodingLocationType = void 0;
    var serialize_1 = require_serialize();
    var client_1 = require_client();
    var ReverseGeocodingLocationType;
    (function(ReverseGeocodingLocationType2) {
      ReverseGeocodingLocationType2["ROOFTOP"] = "ROOFTOP";
      ReverseGeocodingLocationType2["RANGE_INTERPOLATED"] = "RANGE_INTERPOLATED";
      ReverseGeocodingLocationType2["GEOMETRIC_CENTER"] = "GEOMETRIC_CENTER";
      ReverseGeocodingLocationType2["APPROXIMATE"] = "APPROXIMATE";
    })(ReverseGeocodingLocationType = exports.ReverseGeocodingLocationType || (exports.ReverseGeocodingLocationType = {}));
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/geocode/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      latlng: serialize_1.latLngToString
    }, exports.defaultUrl);
    function reverseGeocode(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.reverseGeocode = reverseGeocode;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/roads/snaptoroads.js
var require_snaptoroads = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/roads/snaptoroads.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.snapToRoads = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://roads.googleapis.com/v1/snapToRoads";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      path: (o2) => o2.map(serialize_1.latLngToString)
    }, exports.defaultUrl);
    function snapToRoads(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.snapToRoads = snapToRoads;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/places/textsearch.js
var require_textsearch = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/places/textsearch.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.textSearch = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var client_1 = require_client();
    var serialize_1 = require_serialize();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/place/textsearch/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({ location: serialize_1.latLngToString }, exports.defaultUrl);
    function textSearch(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.textSearch = textSearch;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/timezone.js
var require_timezone = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/timezone.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timezone = exports.defaultParamsSerializer = exports.defaultUrl = void 0;
    var serialize_1 = require_serialize();
    var client_1 = require_client();
    exports.defaultUrl = "https://maps.googleapis.com/maps/api/timezone/json";
    exports.defaultParamsSerializer = (0, serialize_1.serializer)({
      timestamp: serialize_1.toTimestamp,
      location: serialize_1.latLngToString
    }, exports.defaultUrl);
    function timezone(_a, axiosInstance) {
      var { params, method = "get", url = exports.defaultUrl, paramsSerializer = exports.defaultParamsSerializer } = _a, config = __rest(_a, ["params", "method", "url", "paramsSerializer"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url,
        paramsSerializer
      }, config));
    }
    exports.timezone = timezone;
  }
});

// ../../node_modules/agentkeepalive/browser.js
var require_browser = __commonJS({
  "../../node_modules/agentkeepalive/browser.js"(exports, module) {
    module.exports = noop;
    module.exports.HttpsAgent = noop;
    function noop() {
    }
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/common.js
var require_common = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadioType = exports.LocationType = exports.GeocodingAddressComponentType = exports.VehicleType = exports.Maneuver = exports.AddressType = exports.GeocodedWaypointStatus = exports.DirectionsReponseStatus = exports.DirectionsResponseStatus = exports.TransitRoutingPreference = exports.TransitMode = exports.TrafficModel = exports.UnitSystem = exports.TravelRestriction = exports.TravelMode = exports.Language = exports.AspectRatingType = exports.PlaceType2 = exports.PlaceType1 = exports.PlaceInputType = exports.PlaceIdScope = exports.Status = void 0;
    var Status;
    (function(Status2) {
      Status2["OK"] = "OK";
      Status2["INVALID_REQUEST"] = "INVALID_REQUEST";
      Status2["MAX_WAYPOINTS_EXCEEDED"] = "MAX_WAYPOINTS_EXCEEDED";
      Status2["MAX_ROUTE_LENGTH_EXCEEDED"] = "MAX_ROUTE_LENGTH_EXCEEDED";
      Status2["OVER_DAILY_LIMIT"] = "OVER_DAILY_LIMIT";
      Status2["OVER_QUERY_LIMIT"] = "OVER_QUERY_LIMIT";
      Status2["REQUEST_DENIED"] = "REQUEST_DENIED";
      Status2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      Status2["ZERO_RESULTS"] = "ZERO_RESULTS";
      Status2["NOT_FOUND"] = "NOT_FOUND";
    })(Status = exports.Status || (exports.Status = {}));
    var PlaceIdScope;
    (function(PlaceIdScope2) {
      PlaceIdScope2["APP"] = "APP";
      PlaceIdScope2["GOOGLE"] = "GOOGLE";
    })(PlaceIdScope = exports.PlaceIdScope || (exports.PlaceIdScope = {}));
    var PlaceInputType;
    (function(PlaceInputType2) {
      PlaceInputType2["textQuery"] = "textquery";
      PlaceInputType2["phoneNumber"] = "phonenumber";
    })(PlaceInputType = exports.PlaceInputType || (exports.PlaceInputType = {}));
    var PlaceType1;
    (function(PlaceType12) {
      PlaceType12["accounting"] = "accounting";
      PlaceType12["airport"] = "airport";
      PlaceType12["amusement_park"] = "amusement_park";
      PlaceType12["aquarium"] = "aquarium";
      PlaceType12["art_gallery"] = "art_gallery";
      PlaceType12["atm"] = "atm";
      PlaceType12["bakery"] = "bakery";
      PlaceType12["bank"] = "bank";
      PlaceType12["bar"] = "bar";
      PlaceType12["beauty_salon"] = "beauty_salon";
      PlaceType12["bicycle_store"] = "bicycle_store";
      PlaceType12["book_store"] = "book_store";
      PlaceType12["bowling_alley"] = "bowling_alley";
      PlaceType12["bus_station"] = "bus_station";
      PlaceType12["cafe"] = "cafe";
      PlaceType12["campground"] = "campground";
      PlaceType12["car_dealer"] = "car_dealer";
      PlaceType12["car_rental"] = "car_rental";
      PlaceType12["car_repair"] = "car_repair";
      PlaceType12["car_wash"] = "car_wash";
      PlaceType12["casino"] = "casino";
      PlaceType12["cemetery"] = "cemetery";
      PlaceType12["church"] = "church";
      PlaceType12["city_hall"] = "city_hall";
      PlaceType12["clothing_store"] = "clothing_store";
      PlaceType12["convenience_store"] = "convenience_store";
      PlaceType12["courthouse"] = "courthouse";
      PlaceType12["dentist"] = "dentist";
      PlaceType12["department_store"] = "department_store";
      PlaceType12["doctor"] = "doctor";
      PlaceType12["drugstore"] = "drugstore";
      PlaceType12["electrician"] = "electrician";
      PlaceType12["electronics_store"] = "electronics_store";
      PlaceType12["embassy"] = "embassy";
      PlaceType12["fire_station"] = "fire_station";
      PlaceType12["florist"] = "florist";
      PlaceType12["funeral_home"] = "funeral_home";
      PlaceType12["furniture_store"] = "furniture_store";
      PlaceType12["gas_station"] = "gas_station";
      PlaceType12["gym"] = "gym";
      PlaceType12["hair_care"] = "hair_care";
      PlaceType12["hardware_store"] = "hardware_store";
      PlaceType12["hindu_temple"] = "hindu_temple";
      PlaceType12["home_goods_store"] = "home_goods_store";
      PlaceType12["hospital"] = "hospital";
      PlaceType12["insurance_agency"] = "insurance_agency";
      PlaceType12["jewelry_store"] = "jewelry_store";
      PlaceType12["laundry"] = "laundry";
      PlaceType12["lawyer"] = "lawyer";
      PlaceType12["library"] = "library";
      PlaceType12["light_rail_station"] = "light_rail_station";
      PlaceType12["liquor_store"] = "liquor_store";
      PlaceType12["local_government_office"] = "local_government_office";
      PlaceType12["locksmith"] = "locksmith";
      PlaceType12["lodging"] = "lodging";
      PlaceType12["meal_delivery"] = "meal_delivery";
      PlaceType12["meal_takeaway"] = "meal_takeaway";
      PlaceType12["mosque"] = "mosque";
      PlaceType12["movie_rental"] = "movie_rental";
      PlaceType12["movie_theater"] = "movie_theater";
      PlaceType12["moving_company"] = "moving_company";
      PlaceType12["museum"] = "museum";
      PlaceType12["night_club"] = "night_club";
      PlaceType12["painter"] = "painter";
      PlaceType12["park"] = "park";
      PlaceType12["parking"] = "parking";
      PlaceType12["pet_store"] = "pet_store";
      PlaceType12["pharmacy"] = "pharmacy";
      PlaceType12["physiotherapist"] = "physiotherapist";
      PlaceType12["plumber"] = "plumber";
      PlaceType12["police"] = "police";
      PlaceType12["post_office"] = "post_office";
      PlaceType12["real_estate_agency"] = "real_estate_agency";
      PlaceType12["restaurant"] = "restaurant";
      PlaceType12["roofing_contractor"] = "roofing_contractor";
      PlaceType12["rv_park"] = "rv_park";
      PlaceType12["school"] = "school";
      PlaceType12["secondary_school"] = "secondary_school";
      PlaceType12["shoe_store"] = "shoe_store";
      PlaceType12["shopping_mall"] = "shopping_mall";
      PlaceType12["spa"] = "spa";
      PlaceType12["stadium"] = "stadium";
      PlaceType12["storage"] = "storage";
      PlaceType12["store"] = "store";
      PlaceType12["subway_station"] = "subway_station";
      PlaceType12["supermarket"] = "supermarket";
      PlaceType12["synagogue"] = "synagogue";
      PlaceType12["taxi_stand"] = "taxi_stand";
      PlaceType12["tourist_attraction"] = "tourist_attraction";
      PlaceType12["train_station"] = "train_station";
      PlaceType12["transit_station"] = "transit_station";
      PlaceType12["travel_agency"] = "travel_agency";
      PlaceType12["university"] = "university";
      PlaceType12["veterinary_care"] = "veterinary_care";
      PlaceType12["zoo"] = "zoo";
    })(PlaceType1 = exports.PlaceType1 || (exports.PlaceType1 = {}));
    var PlaceType2;
    (function(PlaceType22) {
      PlaceType22["administrative_area_level_1"] = "administrative_area_level_1";
      PlaceType22["administrative_area_level_2"] = "administrative_area_level_2";
      PlaceType22["administrative_area_level_3"] = "administrative_area_level_3";
      PlaceType22["administrative_area_level_4"] = "administrative_area_level_4";
      PlaceType22["administrative_area_level_5"] = "administrative_area_level_5";
      PlaceType22["archipelago"] = "archipelago";
      PlaceType22["colloquial_area"] = "colloquial_area";
      PlaceType22["continent"] = "continent";
      PlaceType22["country"] = "country";
      PlaceType22["establishment"] = "establishment";
      PlaceType22["finance"] = "finance";
      PlaceType22["floor"] = "floor";
      PlaceType22["food"] = "food";
      PlaceType22["general_contractor"] = "general_contractor";
      PlaceType22["geocode"] = "geocode";
      PlaceType22["health"] = "health";
      PlaceType22["intersection"] = "intersection";
      PlaceType22["landmark"] = "landmark";
      PlaceType22["locality"] = "locality";
      PlaceType22["natural_feature"] = "natural_feature";
      PlaceType22["neighborhood"] = "neighborhood";
      PlaceType22["place_of_worship"] = "place_of_worship";
      PlaceType22["plus_code"] = "plus_code";
      PlaceType22["point_of_interest"] = "point_of_interest";
      PlaceType22["political"] = "political";
      PlaceType22["post_box"] = "post_box";
      PlaceType22["postal_code"] = "postal_code";
      PlaceType22["postal_code_prefix"] = "postal_code_prefix";
      PlaceType22["postal_code_suffix"] = "postal_code_suffix";
      PlaceType22["postal_town"] = "postal_town";
      PlaceType22["premise"] = "premise";
      PlaceType22["room"] = "room";
      PlaceType22["route"] = "route";
      PlaceType22["street_address"] = "street_address";
      PlaceType22["street_number"] = "street_number";
      PlaceType22["sublocality"] = "sublocality";
      PlaceType22["sublocality_level_1"] = "sublocality_level_1";
      PlaceType22["sublocality_level_2"] = "sublocality_level_2";
      PlaceType22["sublocality_level_3"] = "sublocality_level_3";
      PlaceType22["sublocality_level_4"] = "sublocality_level_4";
      PlaceType22["sublocality_level_5"] = "sublocality_level_5";
      PlaceType22["subpremise"] = "subpremise";
      PlaceType22["town_square"] = "town_square";
    })(PlaceType2 = exports.PlaceType2 || (exports.PlaceType2 = {}));
    var AspectRatingType;
    (function(AspectRatingType2) {
      AspectRatingType2["appeal"] = "appeal";
      AspectRatingType2["atmosphere"] = "atmosphere";
      AspectRatingType2["decor"] = "decor";
      AspectRatingType2["facilities"] = "facilities";
      AspectRatingType2["food"] = "food";
      AspectRatingType2["overall"] = "overall";
      AspectRatingType2["quality"] = "quality";
      AspectRatingType2["service"] = "service";
    })(AspectRatingType = exports.AspectRatingType || (exports.AspectRatingType = {}));
    var Language;
    (function(Language2) {
      Language2["ar"] = "ar";
      Language2["be"] = "be";
      Language2["bg"] = "bg";
      Language2["bn"] = "bn";
      Language2["ca"] = "ca";
      Language2["cs"] = "cs";
      Language2["da"] = "da";
      Language2["de"] = "de";
      Language2["el"] = "el";
      Language2["en"] = "en";
      Language2["en_Au"] = "en-Au";
      Language2["en_GB"] = "en-GB";
      Language2["es"] = "es";
      Language2["eu"] = "eu";
      Language2["fa"] = "fa";
      Language2["fi"] = "fi";
      Language2["fil"] = "fil";
      Language2["fr"] = "fr";
      Language2["gl"] = "gl";
      Language2["gu"] = "gu";
      Language2["hi"] = "hi";
      Language2["hr"] = "hr";
      Language2["hu"] = "hu";
      Language2["id"] = "id";
      Language2["it"] = "it";
      Language2["iw"] = "iw";
      Language2["ja"] = "ja";
      Language2["kk"] = "kk";
      Language2["kn"] = "kn";
      Language2["ko"] = "ko";
      Language2["ky"] = "ky";
      Language2["lt"] = "lt";
      Language2["lv"] = "lv";
      Language2["mk"] = "mk";
      Language2["ml"] = "ml";
      Language2["mr"] = "mr";
      Language2["my"] = "my";
      Language2["nl"] = "nl";
      Language2["no"] = "no";
      Language2["pa"] = "pa";
      Language2["pl"] = "pl";
      Language2["pt"] = "pt";
      Language2["pt_BR"] = "pt-BR";
      Language2["pt_PT"] = "pt-PT";
      Language2["ro"] = "ro";
      Language2["ru"] = "ru";
      Language2["sk"] = "sk";
      Language2["sl"] = "sl";
      Language2["sq"] = "sq";
      Language2["sr"] = "sr";
      Language2["sv"] = "sv";
      Language2["ta"] = "ta";
      Language2["te"] = "te";
      Language2["th"] = "th";
      Language2["tl"] = "tl";
      Language2["tr"] = "tr";
      Language2["uk"] = "uk";
      Language2["uz"] = "uz";
      Language2["vi"] = "vi";
      Language2["zh_CN"] = "zh-CN";
      Language2["zh_TW"] = "zh-TW";
    })(Language = exports.Language || (exports.Language = {}));
    var TravelMode;
    (function(TravelMode2) {
      TravelMode2["driving"] = "driving";
      TravelMode2["walking"] = "walking";
      TravelMode2["bicycling"] = "bicycling";
      TravelMode2["transit"] = "transit";
    })(TravelMode = exports.TravelMode || (exports.TravelMode = {}));
    var TravelRestriction;
    (function(TravelRestriction2) {
      TravelRestriction2["tolls"] = "tolls";
      TravelRestriction2["highways"] = "highways";
      TravelRestriction2["ferries"] = "ferries";
      TravelRestriction2["indoor"] = "indoor";
    })(TravelRestriction = exports.TravelRestriction || (exports.TravelRestriction = {}));
    var UnitSystem;
    (function(UnitSystem2) {
      UnitSystem2["metric"] = "metric";
      UnitSystem2["imperial"] = "imperial";
    })(UnitSystem = exports.UnitSystem || (exports.UnitSystem = {}));
    var TrafficModel;
    (function(TrafficModel2) {
      TrafficModel2["best_guess"] = "best_guess";
      TrafficModel2["pessimistic"] = "pessimistic";
      TrafficModel2["optimistic"] = "optimistic";
    })(TrafficModel = exports.TrafficModel || (exports.TrafficModel = {}));
    var TransitMode;
    (function(TransitMode2) {
      TransitMode2["bus"] = "bus";
      TransitMode2["subway"] = "subway";
      TransitMode2["train"] = "train";
      TransitMode2["tram"] = "tram";
      TransitMode2["rail"] = "rail";
    })(TransitMode = exports.TransitMode || (exports.TransitMode = {}));
    var TransitRoutingPreference;
    (function(TransitRoutingPreference2) {
      TransitRoutingPreference2["less_walking"] = "less_walking";
      TransitRoutingPreference2["fewer_transfers"] = "fewer_transfers";
    })(TransitRoutingPreference = exports.TransitRoutingPreference || (exports.TransitRoutingPreference = {}));
    var DirectionsResponseStatus;
    (function(DirectionsResponseStatus2) {
      DirectionsResponseStatus2["OK"] = "OK";
      DirectionsResponseStatus2["NOT_FOUND"] = "NOT_FOUND";
      DirectionsResponseStatus2["ZERO_RESULTS"] = "ZERO_RESULTS";
      DirectionsResponseStatus2["MAX_WAYPOINTS_EXCEEDED"] = "MAX_WAYPOINTS_EXCEEDED";
      DirectionsResponseStatus2["MAX_ROUTE_LENGTH_EXCEEDED"] = "MAX_ROUTE_LENGTH_EXCEEDED";
      DirectionsResponseStatus2["INVALID_REQUEST"] = "INVALID_REQUEST";
      DirectionsResponseStatus2["OVER_DAILY_LIMIT"] = "OVER_DAILY_LIMIT";
      DirectionsResponseStatus2["OVER_QUERY_LIMIT"] = "OVER_QUERY_LIMIT";
      DirectionsResponseStatus2["REQUEST_DENIED"] = "REQUEST_DENIED";
      DirectionsResponseStatus2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    })(DirectionsResponseStatus = exports.DirectionsResponseStatus || (exports.DirectionsResponseStatus = {}));
    var DirectionsReponseStatus;
    (function(DirectionsReponseStatus2) {
      DirectionsReponseStatus2["OK"] = "OK";
      DirectionsReponseStatus2["NOT_FOUND"] = "NOT_FOUND";
      DirectionsReponseStatus2["ZERO_RESULTS"] = "ZERO_RESULTS";
      DirectionsReponseStatus2["MAX_WAYPOINTS_EXCEEDED"] = "MAX_WAYPOINTS_EXCEEDED";
      DirectionsReponseStatus2["MAX_ROUTE_LENGTH_EXCEEDED"] = "MAX_ROUTE_LENGTH_EXCEEDED";
      DirectionsReponseStatus2["INVALID_REQUEST"] = "INVALID_REQUEST";
      DirectionsReponseStatus2["OVER_DAILY_LIMIT"] = "OVER_DAILY_LIMIT";
      DirectionsReponseStatus2["OVER_QUERY_LIMIT"] = "OVER_QUERY_LIMIT";
      DirectionsReponseStatus2["REQUEST_DENIED"] = "REQUEST_DENIED";
      DirectionsReponseStatus2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    })(DirectionsReponseStatus = exports.DirectionsReponseStatus || (exports.DirectionsReponseStatus = {}));
    var GeocodedWaypointStatus;
    (function(GeocodedWaypointStatus2) {
      GeocodedWaypointStatus2["OK"] = "OK";
      GeocodedWaypointStatus2["ZERO_RESULTS"] = "ZERO_RESULTS";
    })(GeocodedWaypointStatus = exports.GeocodedWaypointStatus || (exports.GeocodedWaypointStatus = {}));
    exports.AddressType = Object.assign({}, PlaceType1, PlaceType2);
    var Maneuver;
    (function(Maneuver2) {
      Maneuver2["turn_slight_left"] = "turn-slight-left";
      Maneuver2["turn_sharp_left"] = "turn-sharp-left";
      Maneuver2["uturn_left"] = "uturn-left";
      Maneuver2["turn_left"] = "turn-left";
      Maneuver2["turn_slight_right"] = "turn-slight-right";
      Maneuver2["turn_sharp_right"] = "turn-sharp-right";
      Maneuver2["uturn_right"] = "uturn-right";
      Maneuver2["turn_right"] = "turn-right";
      Maneuver2["straight"] = "straight";
      Maneuver2["ramp_left"] = "ramp-left";
      Maneuver2["ramp_right"] = "ramp-right";
      Maneuver2["merge"] = "merge";
      Maneuver2["fork_left"] = "fork-left";
      Maneuver2["fork_right"] = "fork-right";
      Maneuver2["ferry"] = "ferry";
      Maneuver2["ferry_train"] = "ferry-train";
      Maneuver2["roundabout_left"] = "roundabout-left";
      Maneuver2["roundabout_right"] = "roundabout-right";
    })(Maneuver = exports.Maneuver || (exports.Maneuver = {}));
    var VehicleType;
    (function(VehicleType2) {
      VehicleType2["RAIL"] = "RAIL";
      VehicleType2["METRO_RAIL"] = "METRO_RAIL";
      VehicleType2["SUBWAY"] = "SUBWAY";
      VehicleType2["TRAM"] = "TRAM";
      VehicleType2["MONORAIL"] = "MONORAIL";
      VehicleType2["HEAVY_RAIL"] = "HEAVY_RAIL";
      VehicleType2["COMMUTER_TRAIN"] = "COMMUTER_TRAIN";
      VehicleType2["HIGH_SPEED_TRAIN"] = "HIGH_SPEED_TRAIN";
      VehicleType2["BUS"] = "BUS";
      VehicleType2["INTERCITY_BUS"] = "INTERCITY_BUS";
      VehicleType2["TROLLEYBUS"] = "TROLLEYBUS";
      VehicleType2["SHARE_TAXI"] = "SHARE_TAXI";
      VehicleType2["FERRY"] = "FERRY";
      VehicleType2["CABLE_CAR"] = "CABLE_CAR";
      VehicleType2["GONDOLA_LIFT"] = "GONDOLA_LIFT";
      VehicleType2["FUNICULAR"] = "FUNICULAR";
      VehicleType2["OTHER"] = "OTHER";
    })(VehicleType = exports.VehicleType || (exports.VehicleType = {}));
    var GeocodingAddressComponentType;
    (function(GeocodingAddressComponentType2) {
      GeocodingAddressComponentType2["floor"] = "floor";
      GeocodingAddressComponentType2["establishment"] = "establishment";
      GeocodingAddressComponentType2["point_of_interest"] = "point_of_interest";
      GeocodingAddressComponentType2["parking"] = "parking";
      GeocodingAddressComponentType2["post_box"] = "post_box";
      GeocodingAddressComponentType2["postal_town"] = "postal_town";
      GeocodingAddressComponentType2["room"] = "room";
      GeocodingAddressComponentType2["street_number"] = "street_number";
      GeocodingAddressComponentType2["bus_station"] = "bus_station";
      GeocodingAddressComponentType2["train_station"] = "train_station";
      GeocodingAddressComponentType2["transit_station"] = "transit_station";
    })(GeocodingAddressComponentType = exports.GeocodingAddressComponentType || (exports.GeocodingAddressComponentType = {}));
    var LocationType;
    (function(LocationType2) {
      LocationType2["ROOFTOP"] = "ROOFTOP";
      LocationType2["RANGE_INTERPOLATED"] = "RANGE_INTERPOLATED";
      LocationType2["GEOMETRIC_CENTER"] = "GEOMETRIC_CENTER";
      LocationType2["APPROXIMATE"] = "APPROXIMATE";
    })(LocationType = exports.LocationType || (exports.LocationType = {}));
    var RadioType;
    (function(RadioType2) {
      RadioType2["lte"] = "lte";
      RadioType2["gsm"] = "gsm";
      RadioType2["cdma"] = "cdma";
      RadioType2["wcdma"] = "wcdma";
    })(RadioType = exports.RadioType || (exports.RadioType = {}));
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/adapter.js
var require_adapter = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.customAdapter = exports.statusToCode = void 0;
    var settle = require_settle();
    var defaults = require_defaults();
    var transformData = require_transformData();
    var common_1 = require_common();
    function statusToCode(status) {
      switch (status) {
        case common_1.Status.OK:
        case common_1.Status.ZERO_RESULTS: {
          return 200;
        }
        case common_1.Status.INVALID_REQUEST:
        case common_1.Status.MAX_ROUTE_LENGTH_EXCEEDED:
        case common_1.Status.MAX_WAYPOINTS_EXCEEDED: {
          return 400;
        }
        case common_1.Status.REQUEST_DENIED: {
          return 403;
        }
        case common_1.Status.NOT_FOUND: {
          return 404;
        }
        case common_1.Status.OVER_DAILY_LIMIT:
        case common_1.Status.OVER_QUERY_LIMIT: {
          return 429;
        }
        case common_1.Status.UNKNOWN_ERROR: {
          return 500;
        }
        default: {
          return 200;
        }
      }
    }
    exports.statusToCode = statusToCode;
    var customAdapter = (config) => new Promise((resolve, reject) => {
      defaults.adapter(config).then((r2) => {
        r2.data = transformData(r2.data, r2.headers, config.transformResponse);
        if (r2.status === 200 && r2.data.status) {
          r2.status = statusToCode(r2.data.status);
        }
        settle(resolve, reject, r2);
      }).catch(reject);
    });
    exports.customAdapter = customAdapter;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/package.json
var require_package = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/package.json"(exports, module) {
    module.exports = {
      name: "@googlemaps/google-maps-services-js",
      version: "3.3.29",
      description: "Node.js client library for Google Maps API Web Services",
      keywords: [
        "google",
        "maps",
        "googlemaps",
        "geo",
        "geocode",
        "timezone",
        "api",
        "client",
        "roads",
        "directions",
        "navigation"
      ],
      homepage: "https://github.com/googlemaps/google-maps-services-js",
      bugs: {
        url: "https://github.com/googlemaps/google-maps-services-js/issues"
      },
      repository: {
        type: "git",
        url: "https://github.com/googlemaps/google-maps-services-js.git"
      },
      license: "Apache-2.0",
      author: "Google Inc.",
      contributors: [
        {
          name: "Justin Poehnelt",
          email: "jpoehnelt@google.com"
        }
      ],
      main: "./dist/index.js",
      files: [
        "dist",
        "src"
      ],
      scripts: {
        docs: "rm -rf docs/ && typedoc src/index.ts",
        prepare: "tsc",
        test: "jest src",
        "test:e2e": "jest e2e",
        "test:all": "jest"
      },
      dependencies: {
        "@googlemaps/url-signature": "^1.0.4",
        agentkeepalive: "^4.1.0",
        axios: "^0.27.2",
        "query-string": "^7.1.3",
        "retry-axios": "^2.6.0"
      },
      devDependencies: {
        "@types/jest": "^27.0.0",
        "@types/node": "^18.0.0",
        jest: "^27.0.0",
        nock: "^13.0.4",
        prettier: "^2.0.5",
        "ts-jest": "^27.0.5",
        typedoc: "^0.24.1",
        typescript: "^4.0.0"
      },
      publishConfig: {
        registry: "https://wombat-dressing-room.appspot.com",
        access: "public"
      }
    };
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/client.js
var require_client = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.defaultAxiosInstance = exports.X_GOOG_MAPS_EXPERIENCE_ID = exports.acceptEncoding = exports.userAgent = exports.defaultTimeout = exports.defaultHttpsAgent = exports.version = void 0;
    var rax = (init_index_module(), __toCommonJS(index_module_exports));
    var directions_1 = require_directions();
    var distance_1 = require_distance();
    var elevation_1 = require_elevation();
    var findplacefromtext_1 = require_findplacefromtext();
    var geocode_1 = require_geocode();
    var geolocate_1 = require_geolocate();
    var nearestroads_1 = require_nearestroads();
    var autocomplete_1 = require_autocomplete();
    var details_1 = require_details();
    var photo_1 = require_photo();
    var queryautocomplete_1 = require_queryautocomplete();
    var placesnearby_1 = require_placesnearby();
    var reversegeocode_1 = require_reversegeocode();
    var snaptoroads_1 = require_snaptoroads();
    var textsearch_1 = require_textsearch();
    var timezone_1 = require_timezone();
    var axios_1 = require_axios();
    var agentkeepalive_1 = require_browser();
    var adapter_1 = require_adapter();
    exports.version = require_package().version;
    exports.defaultHttpsAgent = new agentkeepalive_1.HttpsAgent({ keepAlive: true });
    exports.defaultTimeout = 1e4;
    exports.userAgent = `google-maps-services-node-${exports.version}`;
    exports.acceptEncoding = "gzip";
    exports.X_GOOG_MAPS_EXPERIENCE_ID = "X-GOOG-MAPS-EXPERIENCE-ID";
    var defaultConfig = {
      timeout: exports.defaultTimeout,
      httpsAgent: exports.defaultHttpsAgent,
      adapter: adapter_1.customAdapter,
      headers: {
        "User-Agent": exports.userAgent,
        "Accept-Encoding": exports.acceptEncoding
      }
    };
    exports.defaultAxiosInstance = axios_1.default.create(defaultConfig);
    rax.attach(exports.defaultAxiosInstance);
    var Client = class {
      constructor({ axiosInstance, config, experienceId } = {}) {
        if (axiosInstance && config) {
          throw new Error("Provide one of axiosInstance or config.");
        }
        if (axiosInstance) {
          this.axiosInstance = axiosInstance;
          this.axiosInstance.defaults.headers = Object.assign(Object.assign({}, defaultConfig.headers), this.axiosInstance.defaults.headers);
        } else if (config) {
          config = Object.assign(Object.assign({}, defaultConfig), config);
          config.headers = Object.assign(Object.assign({}, defaultConfig.headers), config.headers || {});
          this.axiosInstance = axios_1.default.create(config);
          rax.attach(this.axiosInstance);
        } else {
          this.axiosInstance = exports.defaultAxiosInstance;
        }
        if (experienceId) {
          this.setExperienceId(...experienceId);
        }
      }
      setExperienceId(...ids) {
        this.experienceId = ids;
        this.axiosInstance.defaults.headers[exports.X_GOOG_MAPS_EXPERIENCE_ID] = ids.join(",");
      }
      clearExperienceId() {
        this.experienceId = null;
        this.clearExperienceIdHeader();
      }
      clearExperienceIdHeader() {
        delete this.axiosInstance.defaults.headers[exports.X_GOOG_MAPS_EXPERIENCE_ID];
      }
      getExperienceId() {
        return this.experienceId;
      }
      directions(request) {
        return (0, directions_1.directions)(request, this.axiosInstance);
      }
      distancematrix(request) {
        return (0, distance_1.distancematrix)(request, this.axiosInstance);
      }
      elevation(request) {
        return (0, elevation_1.elevation)(request, this.axiosInstance);
      }
      timezone(request) {
        return (0, timezone_1.timezone)(request, this.axiosInstance);
      }
      geolocate(request) {
        return (0, geolocate_1.geolocate)(request, this.axiosInstance);
      }
      /**
       * An example use of this function.
       *
       * ```javascript
       * import { Client } from '@googlemaps/google-maps-services-js';
       *
       * const args = {
       *   params: {
       *     key: '<your-api-key>',
       *     address: 'Perth 4WD & Commercial Centre',
       *   }
       * };
       * const client = new Client();
       * client.geocode(args).then(gcResponse => {
       *   const str = JSON.stringify(gcResponse.data.results[0]);
       *   console.log(`First result is: ${str}`);)
       * });
       * ```
       */
      geocode(request) {
        return (0, geocode_1.geocode)(request, this.axiosInstance);
      }
      reverseGeocode(request) {
        return (0, reversegeocode_1.reverseGeocode)(request, this.axiosInstance);
      }
      placeAutocomplete(request) {
        return (0, autocomplete_1.placeAutocomplete)(request, this.axiosInstance);
      }
      placeDetails(request) {
        return (0, details_1.placeDetails)(request, this.axiosInstance);
      }
      findPlaceFromText(request) {
        return (0, findplacefromtext_1.findPlaceFromText)(request, this.axiosInstance);
      }
      placePhoto(request) {
        return (0, photo_1.placePhoto)(request, this.axiosInstance);
      }
      placesNearby(request) {
        return (0, placesnearby_1.placesNearby)(request, this.axiosInstance);
      }
      placeQueryAutocomplete(request) {
        return (0, queryautocomplete_1.placeQueryAutocomplete)(request, this.axiosInstance);
      }
      textSearch(request) {
        return (0, textsearch_1.textSearch)(request, this.axiosInstance);
      }
      nearestRoads(request) {
        return (0, nearestroads_1.nearestRoads)(request, this.axiosInstance);
      }
      snapToRoads(request) {
        return (0, snaptoroads_1.snapToRoads)(request, this.axiosInstance);
      }
    };
    exports.Client = Client;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/geolocate.js
var require_geolocate = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/geolocate.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.geolocate = exports.defaultUrl = exports.GeolocateErrorReason = void 0;
    var client_1 = require_client();
    var GeolocateErrorReason;
    (function(GeolocateErrorReason2) {
      GeolocateErrorReason2["dailyLimitExceeded"] = "dailyLimitExceeded";
      GeolocateErrorReason2["keyInvalid"] = "keyInvalid";
      GeolocateErrorReason2["userRateLimitExceeded"] = "userRateLimitExceeded";
      GeolocateErrorReason2["notFound"] = "notFound";
      GeolocateErrorReason2["parseError"] = "parseError";
    })(GeolocateErrorReason = exports.GeolocateErrorReason || (exports.GeolocateErrorReason = {}));
    exports.defaultUrl = "https://www.googleapis.com/geolocation/v1/geolocate";
    function geolocate(_a, axiosInstance) {
      var { params, method = "post", url = exports.defaultUrl } = _a, config = __rest(_a, ["params", "method", "url"]);
      if (axiosInstance === void 0) {
        axiosInstance = client_1.defaultAxiosInstance;
      }
      return axiosInstance(Object.assign({
        params,
        method,
        url
      }, config));
    }
    exports.geolocate = geolocate;
  }
});

// ../../node_modules/@googlemaps/google-maps-services-js/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@googlemaps/google-maps-services-js/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReverseGeocodingLocationType = exports.PlacesNearbyRanking = exports.PlaceAutocompleteType = exports.GeolocateErrorReason = void 0;
    var geolocate_1 = require_geolocate();
    Object.defineProperty(exports, "GeolocateErrorReason", { enumerable: true, get: function() {
      return geolocate_1.GeolocateErrorReason;
    } });
    var autocomplete_1 = require_autocomplete();
    Object.defineProperty(exports, "PlaceAutocompleteType", { enumerable: true, get: function() {
      return autocomplete_1.PlaceAutocompleteType;
    } });
    var placesnearby_1 = require_placesnearby();
    Object.defineProperty(exports, "PlacesNearbyRanking", { enumerable: true, get: function() {
      return placesnearby_1.PlacesNearbyRanking;
    } });
    var reversegeocode_1 = require_reversegeocode();
    Object.defineProperty(exports, "ReverseGeocodingLocationType", { enumerable: true, get: function() {
      return reversegeocode_1.ReverseGeocodingLocationType;
    } });
    __exportStar(require_common(), exports);
    __exportStar(require_client(), exports);
  }
});
export default require_dist();
//# sourceMappingURL=@googlemaps_google-maps-services-js.js.map
